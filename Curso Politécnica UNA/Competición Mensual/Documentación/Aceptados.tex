\chapter{Algoritmos aceptados}


\section{Sandro's Book}

	Se empleó una estructura \verb|unordered_map <string, int>| para almacenar
	todas las subcadenas posibles.
	Luego, navegando por la estructura, se comprobó cuál subcadena aparece la
	mayor cantidad de veces, y en caso de empate, se eligió la más larga.


\section{Emoticons :-)}

	La estructura \verb|Node| es un árbol de búsqueda, cuyas ramas representan
	a los caracteres de las palabras admitidas.
	Para admitir una palabra, se agregan las ramas necesarias, y se señala con
	una bandera el nodo correspondiente al último caracter de la palabra.
	Así, pueden buscarse todas las palabras (emoticones en este caso) a la vez
	en una sola iteración, sin importar el tamaño de ellas.

	Al realizar la búsqueda, halla siempre el emoticón más largo a partir de la
	posición apuntada.
	Una vez hallado, busca a partir de la siguiente posición si hay un emoticón
	que es una subcadena del mismo.
	Si lo halla, repite el mismo procedimiento hasta que no pueda hallar una
	subcadena.

	El final de la última subcadena hallada es el caracter que debe ser
	reemplazado por un espacio.


\section{Pascal Library}

	Este problema fue fácil de resolver. El operador de bits \verb|&| hizo todo
	el trabajo.


\section{Bubble Maps}

	Este problema fue un grato desafío.

	Lo primero fue asociar las letras $p, q, r, s$ con los números 0; 1; 3; 2,
	respectivamente.
	Así, en lugar de observar el comportamiento de las coordenadas desde una
	perspectiva rotacional, se hace desde una perspectiva más cercana a la
	cartesiana.
	Además, se obtienen ciertas ventajas al trabajar con valores numéricos (que
	todo matemático disfruta explotar).

	El siguiente paso fue descubrir el patrón de movimiento:
	\begin{itemize}
		\item Se comienza siempre con el nivel de zoom más cercano. Supóngase
		que se busca mover a la dirección $d$ (arriba, abajo, izquierda o
		derecha).
		\item Si es factible sin salir del nivel de zoom, realiza el movimiento
		y obtiene la coordenada deseada.
		Sino, simula realizar el movimiento contrario (llámese $-d$ si se desea)
		e intenta realizar el movimiento $d$ en el siguiente nivel de zoom
		(cuatro veces mayor que el último visitado).
		\item Si llega al último nivel de zoom, se realiza el mismo procedimiento
		si puede moverse a la dirección $d$.
		Sino, se deduce que la casilla a la que se quiere llegar está fuera del
		mapa.
	\end{itemize}

	Por último, se convierten las coordenadas numéricas nuevamente a las letras
	correspondientes, indicando con \verb|<none>| las casillas que están fuera
	del mapa.


\section{Degrees of Separation}

	Siguiendo el consejo dado en la clase, implementé el algoritmo de
	\emph{Floyd-Warshall} para resolver el problema de las distancias.
	Como no podía haber más de 50 vértices en el grafo, la complejidad
	$O(V^3)$ ($50^3 = \numprint{125000}$) no supuso un problema de rendimiento.

	La parte que podría considerarse más complicada fue la de reconocer las
	repeticiones de los nombres.
	Este problema se pudo resolver con una estructura \verb|map <string, int>|, la cual
	asociaba cada cadena con el índice correspondiente en la matriz del grafo.


\section{Maximum Sum}

	Este problema tuvo bastantes errores graciosos (implementaciones que
	planteaban diferentes formas de resolver el problema, y sin embargo daban
	los mismos números incorrectos).

	Se empleó programación dinámica para resolver el problema, guardando las
	sumas de las líneas horizontales (filas o subfilas, si pueden llamarse así).

	Se diseñó también una función para obtener la suma de un rectángulo, la cual
	obtenía recursivamente la suma del rectángulo de altura inmediatamente
	inferior si el mismo no era una línea horizontal (altura 1).
	En cada llamada a la función, se comparaba el resultado con el máximo valor
	hallado previamente.

	Así, llamando al mínimo de funciones necesarias para comprobar las sumas de
	todos los rectángulos, se obtenía la máxima suma.
	La programación dinámica permitió ejecutar el algoritmo con complejidad
	$O(n^3)$ una vez se almacenaron las sumas de las líneas horizontales.


\section{Closest Point Pair}

	Fue uno de los algoritmos que más tiempo tomó comprenderlos.
	No fue difícil comprender el paso de divide y conquistarás, mas sí costó
	bastantes dolores de cabeza y leer bastantes fuentes distintas comprender
	por qué era suficiente hace tan pocas comprobaciones al comparar dos puntos
	en distintas regiones.

	Una vez comprendida la demostración (como dos semanas después), perdí un día
	porque recibía todo constantemente WA.
	He buscado un problema similar en UVa, \href{http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=1186}
	{``The Closest Pair Problem''}, y no tuve muchos inconvenientes en lograr que
	aceptara mi solución.
	¿Cuál era el problema? Que a pesar de haber leído muchas veces y sospechado,
	no había visto que los índices de la solución debían ser escritos en orden.


\section{How Many?}

	Me enojé con este problema, porque buscaba una solución bien matemática,
	y al final recurrí a una poco elegante programación dinámica.

	A diferencia de la solución propuesta en el material, no contaba si el último
	movimiento fue hacia arriba o hacia abajo, sino que, si necesitaba hacer el
	conteo de algún pico, desplazaba el punto hasta el lugar donde quedaría
	después de un movimiento hacia arriba y otro hacia abajo (dos lugares a la
	izquierda en mi algoritmo, ya que comienza desde la derecha).

	Además, era necesario calcular cuándo llegaba a coordenadas desde las cuales
	sólo podía hacer un movimiento (para incrementar el contador), como la recta
	$y = x$, o puntos desde donde ya era imposible realizar un movimiento válido
	(retornando 0 para no incrementar el contador).


\section{Diagonal}

	Otro problema matemático para divertirse.
	Sabiendo que un polígono de $n$ lados tiene $$d = \frac{n(n-1)}{2}$$
	diagonales, bastaba deducir $n$ en función a $d$ en $$d \leq \frac{n(n-1)}{2}.$$

	Con un poco de álgebra, se llegaba a la desigualdad $$n^2 - 3n - 2d \geq 0,$$
	cuyas posibles soluciones son $$n \geq \frac{3 + \sqrt{9 + 8d}}{2}$$
	o $$n \leq \frac{3 - \sqrt{9 + 8d}}{2}.$$

	Como $n$ y $d$ son enteros positivos, se deduce que
	\begin{align*}
		\frac{3 - \sqrt{9 + 8d}}{2}
			&\leq \frac{3 - \sqrt{17}}{2} \\
			&< \frac{3 - 4}{2} = -\frac{1}{2} \\
			&< 0,
	\end{align*}
	por tanto la segunda solución no es una opción válida para $n$.

	Como sólo queda la primera opción, simplemente basta calcular
	$$n = f(d) = \left\lceil \frac{3 + \sqrt{9 + 8d}}{2} \right\rceil$$
	para resolver el problema.


\section{Lonesome Knight} \label{lonesome_knight}

	Admito que mi solución fue poco elegante, quizás por la prisa por tener algo
	rápido de depurar.

	Simplemente definí una matriz con los números de movimientos posibles en cada
	casilla, escritos a mano.
	Como desde muy pequeño practicaba bastante al ajedrez, no tuve mayores
	problemas en controlar que no hubieran equivocaciones.


\section{Turn the Lights Off}

	Tomé mi código fuente de \hyperref[flip_game]{``Flip Game''} y lo adapté de modo que
	hiciera lo mencionado en la clase: permutar todos los interruptores de la
	primera fila y comprobar si cada permutación permitía que se apagaran todas
	las luces empleando el resto de los interruptores.


\section{Stars}

	Este problema resolví siguiendo los tips dados en clase, después de caer
	rendido miserablemente ante el intento de una solución en menos de 0.25
	segundos.

	Tomó su tiempo entender el algoritmo, algunas pruebas de escritorio para
	entender por qué funcionaba, pero una vez logrado eso, no supuso mucha
	dificultad implementarlo.

	Con esta solución volví a enamorarme del \emph{mergesort}.


\section{Cyclic antimonotonic permutations}

	Seguí el consejo discutido en clase: aprovechar que a partir de dos ciclos
	se puede obtener un nuevo ciclo solamente alterando un enlace por ciclo (se
	separa en dos enlaces cada uno) y hacer la unión entre el ciclo actual de
	$n$ elementos (los enteros del 1 al $n$) con el número $n+1$, de modo que
	se mantenga antimonótona (observando los elementos en posiciones $n-1$ y $n$);
	hasta incluir todos los números solicitados.


\section{Ordering Tasks}

	Este fue el problema que resolví en la clase cuando todo el mundo resolvía
	\hyperref[lonesome_knight]{``Lonesome Knight''} (qué elección para el primer
	problema).

	La idea fue implementar árboles donde cada nodo tenía dos conjuntos: el de
	padres y el de hijos (el hijo depende del padre para ejecutarse).
	Una vez dadas las dependencias, se buscaba el primer nodo sin padres,
	se quitaba a cada hijo suyo a éste en el conjunto de padres, y se eliminaba
	al nodo, para seguir la búsqueda con los demás (no sin antes imprimirlo),
	hasta que no hubiera más nodos (tareas pendientes).


\section{What Goes Up}

	Tomé como referencia un algoritmo que permitía calcular la longitud de la
	\emph{Longest Increasing Subsequence} (\emph{LIS}), sin necesidad de saber cuál es.

	A dicha implementación le di un pequeño retoque: en lugar de almacenar
	solamente los números, almacenaba un par cuyo primer elemento era el número
	a comparar y el segundo un puntero al último número que lo precede (que el
	algoritmo original me permitía saber implícitamente).

	Una vez calculada la longitud de la \emph{LIS}, bastaba navegar por los pares
	de números (comenzando por el último obtenido al calcular la longitud) para
	construir en tiempo lineal toda la lista sin necesidad de consumir mucha
	memoria.


\section{The primary problem} \label{primary_problem}

	Pensaba que era uno de los problemas más fáciles y me llevé una sorpresa
	mayúscula.

	Ya había hecho en el pasado problemas de UVa que solicitaban trabajar con
	números primos e inclusive con la conjetura de Godlbach. Así que pensaba que
	podía tranquilamente adaptar un poco de cada código para tener el resultado
	deseado, y me encontré con un TLE de película.

	Rápidamente comprobé que mi problema era la generación de primos. Me convenía
	tener dos tablas: una de primalidad (\verb|true| si el elemento es primo,
	\verb|false| si no lo es) y otra con la lista de números primos.

	Ninguno de mis algoritmos me permitía con facilidad obtener ambas listas, y
	sin embargo me resistía a hacer la criba de Eratóstenes por considerarla poco
	eficiente.

	Mucho después, resignado, decidí implementarla, con algunas optimizaciones,
	y comprobé que no sólo me daba servidas las dos tablas, sino que\ldots
	¡Era 500 veces más rápida que mis otros algoritmos!

	De más está decir que pedí miles de disculpas a Eratóstenes por haber dudado
	de él.

	Los códigos que pensaba me iban a funcionar fueron \href{http://goo.gl/hV6Bd8}
	{``543 - Goldbach's Conjecture.cpp''} y \href{http://goo.gl/8ycN3e}
	{``Prime Cuts''} (el mismo que también correspondió trabajar).


\section{Minimal coverage}

	Un hermoso algoritmo greedy.

	Apenas al ingresar los datos descarté los segmentos que no podían formar parte
	de la solución, por estar fuera de rango.
	Después, los ordené en función a su extremo izquierdo (hice un caso de
	desempate, pero no fue realmente necesario).

	Así como $M$ era el supremo del intervalo, definí una variable $m$
	(inicialmente 0) que era el ínfimo.
	Así, navegaba desde el primer segmento hasta el último con extremo izquierdo
	no mayor que $m$, y guardaba el mayor extremo derecho que encontraba, cuyo
	valor final asignaría a $m$ (dicho segmento formaría parte de mi lista).

	Repetí este procedimiento con todos los segmentos aún no visitados hasta
	tener $m \geq M$. El número de iteraciones es el conteo la lista donde
	guardaba los segmentos extremos me permitió mostrar el resultado.


\section{Prime Cuts}

	Este problema se resolvió en dos pasos.

	El primero consistió en crear una lista de primos. Como se mencionó en
	\hyperref[primary_problem]{``The primary problem''}, este algoritmo no
	resultó ser el más eficiente, aunque el problema no lo requería.
	Los números primos se generaron comprobando la primalidad de cada número
	mayor que ellos (aprovechando que ya tenía una lista de primos para ahorrar
	cálculos).

	El siguiente paso fue calcular el índice de la mediana de los primeros $N$
	primos (cómo odié al que decidió que 1 también debía ser primo, aún me dan
	arcadas), y según su paridad deduje los índices de los extremos que necesitaba
	para listar los que pedía el enunciado.


\section{Median on the Plane}

	Este problema lo habría hecho sin mirar los tips si leía con más atención y
	observaba que decía claramente que no habían tres puntos colineales.

	Pero como seguí las indicaciones, lo único creativo que pude hacer es elegir
	el punto inferior al mismo tiempo que iba ingresando los puntos y hacer el
	algoritmo para obtener el ángulo teniendo en cuenta el punto de discontinuidad
	en la recta $x = c$ cuando dos puntos están a igual distancia del eje de las
	ordenadas.


\section{Rabbit Hunt}

	Este problema se resolvió con bastante fuerza bruta.

	Por cada par de puntos, se calculó la pendiente y se agregaron ambos puntos
	a una estructura \verb|map <Point, set <Point> >|, donde el primer elemento
	correspondía a la pendiente (con un valor especial para evitar divisiones
	entre 0 si la recta que unía los puntos era vertical) y el segundo al conjunto
	de puntos que compartían esa pendiente.

	Por último, bastaba contar cuál era el conjunto con más elementos para cerrar
	el problema.


\section{Ecological Premium}

	No le falta mucho para competir con problemas como ``A + B'' como el más fácil.

	El único truco del algoritmo se trataba de darse cuenta de que la variable
	\verb|animals| no influía en el resultado de los cálculos.


\section{Funny Game}

	Un algoritmo \emph{minimax} fue todo lo necesario para resolver el problema.

	Tomando como referencia los tips, mi algoritmo reslizó los siguientes pasos:
	\begin{enumerate}
		\item Si el aeropuerto no tenía conexiones disponibles, perdía.
		\item Sino, explotaba el aeropuerto (anulaba las conexiones de los demás
			aeropuertos con éste) e intentaba viajar a cada aeropuerto.
		\item Si desde uno de los aeropuertos se pierde el juego, podía deducir
			que tenía la estrategia ganadora.
	\end{enumerate}

	Haciendo las búsquedas ordenadamente, también es fácil dar con el menor número
	de aeropuerto, tal como solicita el enunciado.


\section{Flip Game} \label{flip_game}

	Como $2^{16} = \numprint{65536}$ no es un valor de gran costo a nivel
	computacional, opté por hacer fuerza bruta con una máscara de bits (bastante
	similar a la opción 1 que se propuso en los tips).

	El único detalle a resaltar fue que implementé un arreglo de $6\times 6$ para
	evitar casos particulares al elegir una casilla en los bordes o las esquinas
	para efectuar un movimiento.


\section{Longest path in a tree}

	Opté por usar el teorema que se mencionó en la clase.

	Hice un recorrido DFS para calcular la profundidad máxima a partir de un nodo
	$N$, de modo que pudiera recordar al nodo $M$ más alejado de $N$.
	Luego hice el DFS a partir de $M$ y el número dado fue el resultado buscado.


\section{Tornado!}

	Este problema no fue difícil, pero tenía sus trampas y había que estar atento.

	Si entre dos postes de concreto había $c$ postes rotos, se necesitaban
	$\left\lfloor \frac{c}{2} \right\rfloor$ postes de madera entre ellos.
	El total de postes se obtenía sumando todos los valores parciales al dar una
	vuelta en el recorrido.

	La trampa estaba cuando no había postes de concreto.
	En ese caso, para $n$ postes rotos, la solución es
	$\left\lfloor \frac{n-1}{2} + 1\right\rfloor$.


\section{Product of Digits}

	Otro algoritmo verdaderamente greedy.

	Contaba primero cuántos factores 9 tenía $N$, y cada vez que hallaba un factor,
	lo dividía por ese número.
	Luego, procedía de la misma forma con los números $8; 7;\ldots;2$ hasta que
	$N = 1$ o se me acabaran los dígitos.

	Si se me acaban los dígitos y $N \neq 1$, entonces sabía que era imposible
	hallar el número solicitado.
	En cambio, si $N = 1$, imprimía cada dígito del 2 al 9, esta vez en orden
	creciente, la cantidad de veces que había hallado cada uno.

	Dos casos que tomé de forma particular fueron el 0 y el 1, que inmediatamente
	devolvían 1 y 10, respectivamente.


\section{Two Teams}

	Este problema parecía más difícil de buenas a primeras, pero facilitaba muchas
	cosas.

	En efecto, el único caso que no tenía solución era cuando había personas sin
	amigos, puesto que:
	\begin{itemize}
		\item Si todo los amigos de una persona están en un equipo, elige el otro.
		\item Si una persona tiene amigos en ambos equipos, elige cualquiera con
			la certeza de que cumplirá las condiciones.
	\end{itemize}

	Así, el problema se convirtió en uno de coloreado de grafos, donde se buscan
	nodos sin pintar.
	Por cada nodo sin pintar, se le asigna un color, y a todos sus amigos sin pintar
	el otro color (y así, recursivamente, pudiendo eliminar las amistades para
	ganar tiempo).
	
	Si hallabas una persona sin pintar y sin amigos, se deducía que era imposible
	formar los equipos.
	Y de poder formarse los equipos, contaba simplemente los nodos que fueron
	pintados de un color y los listaba.


\section{Basic wall maze}

	Este problema resolví haciendo un recorrido BFS mediante una estructura
	\verb|queue <Path>|, donde \verb|Path| almacena la casilla donde se encuentra
	y toda la ruta recorrida hasta el momento (en una cadena).

	Dado que había como mucho $6^2 = 36$ casillas por las cuales pasar, no cabía
	duda de que el algoritmo iba a terminar muy rápidamente.

	La parte más ``difícil'' fue crear una estructura para el tablero que
	permitiera insertar las murallas cómodamente.
	En mi caso, elegí hacer una matriz grande, donde dos casillas adyacentes
	tienen, en la matriz implementada, una casilla entre ellas, que representa
	la existencia de la muralla.
	Luego de hacer la conversió de coordenadas correspondiente, el problema estuvo
	resuelto.


\section{Rope}

	El problema consistió en sumar las distancias de los segmentos y los arcos
	que se formaban en la figura.

	Cada segmento es tangente a dos circunferencias, y fácilmente se demuestra
	que	mide lo mismo que la distancia entre los centros de dichas circunferencias.

	Para sumar los arcos, primero intenté calcular los ángulos que se formaban en
	cada arco, pero me salía tan desprolijo que decidí consultar los tips.
	¿Cómo no se me había ocurrido que todos los arcos suman un giro?
	Podía haberlo deducido si observaba que cada uno tenía la amplitud de un
	ángulo externo del polígono delimitado por los centros.


\section{Binary Lexicographic Sequence}

	En este problema disfruté crear un artificio matemático que me permitió
	dar con cada dígito en el orden que necesitaba imprimir.
	Sí, complejidad $O(n)$, donde $n$ es el número de dígitos a mostrar.

	Me interesaba definir una función $f(n)$ que indicara todos los números que
	podía escribir, siguiendo las reglas, sin tener un 1 en una posición mayor
	que $n$, contando de derecha a izquierda, donde la posición más a la derecha
	es 1 y no 0.
	No me tomó mucho tiempo deducir que la función debía ser:
	$$ f(n) =
		\begin{cases}
			1 &\text{si } n = 0 \\
			2 &\text{si } n = 1 \\
			f(n-1) + f(n-2) &\text{si } n \geq 2
		\end{cases}
	$$

	Cuando $n \geq 2$, $f(n-1)$ representa todos los números anteriormente contados
	y $f(n-2)$ son todos los números a los cuales se puede agregar un 1 en la
	posición $n$ para formar los nuevos números sin tener dos dígitos 1 consecutivos.

	Una vez definida la función, con programación dinámica se delimitaron los
	intervalos donde era seguro que el 1 de mayor valencia estaba en la posición
	$n$.
	Así, era fácil comprobar si el número ingresado estaba dentro del rango: si
	el número $k$ era mayor que $f(k)$, se devolvía -1 y terminaba la ejecución.
	Sino, se hacían los siguientes pasos mientras la cantidad de dígitos $n$
	fuera positiva:
	\begin{enumerate}
		\item Si $k \leq f(n-1)$, imprimir un 0.
		\item Sino, imprimir un 1 y a $k$ restar $f(n-1)$.
		\item Restar una unidad a $n$ después de efectuar cualquiera de los casos.
	\end{enumerate}

	En el momento que $n = 0$, se sabe que ya se imprimieron todos los números.


\section{Distinct Subsequences}

	Este fue otro problema muy bonito de programación dinámica que disfruté
	matemáticamente hacerlo.

	El truco consistió en numerar las posiciones de las letras y, para cada letra,
	guardar la siguiente información:
	\begin{itemize}
		\item Las subsecuencias formadas antes de incluir a la letra en la cadena
			(de ahora en adelante, \verb|previous|).
		\item Las subsecuencias formadas incluyendo a la letra de la cadena
			(\verb|count|).
	\end{itemize}

	Al iniciar el algoritmo, el atributo \verb|count| para cada letra es 0.
	El mismo valor tomará inicialmente \verb|previous|.
	Es fácil deducir que el valor de \verb|count| para la letra en la iteración
	$n-1$ será el valor de \verb|previous| para la letra en la posición $n$.
	Además, en caso de que una letra aparezca repetidas veces, sólo nos importan
	los valores de su última aparición.

	Para calcular el valor de \verb|count| para la letra $c$ en la posición $n$,
	se realizan los siguientes pasos:
	\begin{enumerate}
		\item Se asigna a \verb|count| el doble del valor de \verb|count| para
			la letra en la posición $n-1$ (cada permutación anterior vuelve a
			contarse, esta vez incluyendo a la nueva letra en el extremo).
		\item Se resta el número de subsecuencias que se formaron antes de la
			última aparición de $c$ anterior a la actual, es decir, el último
			\verb|previous| guardado para $c$ (pues son estos los casos en los
			cuales no podría distinguirse cuál de las dos $c$ se posicionó en
			el extremo).
		\item Terminado de calcular \verb|count|, se calcula el nuevo valor de
			\verb|previous| como se dijo anteriormente.
	\end{enumerate}

	Terminado el procedimiento para la última letra, su atributo \verb|count|
	tiene el valor que estábamos buscando.
	Lo más interesante fue descubrir que sólo necesitaba tener tanto espacio de
	memoria como letras posibles a escribirse, pues permite hacer un algoritmo
	de complejidad $O(n)$ usando un espacio de memoria de tamaño constante.

	\paragraph{Observaciones:}
	\begin{itemize}
		\item En el algoritmo, cada operación numérica fue adaptada de tal modo
			que cumpla con el requisito de que el resultado final sea un valor
			en el intervalo $[0;\numprint{1000000007})$.
		\item En la línea 31 del código fuente (página \pageref{code_distinct_subsecuences}),
			puede apreciarse la condición \lstinline|if ( sub[c].count )|.
			Al revisar el código, creo que no es en realidad necesario considerar
			esta condición, pero lo conservo como tal porque fue así como lo envié
			al juez virtual.
	\end{itemize}


\section{Edit distance}

	Para este problema, no tuve tanta facilidad al plantearlo, y no me quedó otra
	que aprender el algoritmo de \emph{Levenshtein} e implementarlo una vez
	entendido.

	Personalmente, aún me quedan dudas en la demostración de por qué el artificio
	de agregar espacios entre algunas letras es clave a la hora de resover el
	problema.
	Es algo que me queda por investigar.


\section{Cutting Sticks}

	Este problema parecía bastante atacable con algún artificio matemático, pero
	más tarde que temprano me vi obligado a tomar el camino que menos quería:
	probar todas las permutaciones posibles (aunque la programación dinámica lo
	hiciera más eficiente).

	En un primer intento, quería trabajar con los trozos que debían formarse (si
	tengo una barra de 10 metros y la corto en los lugares 2; 4 y 7 tenía trozos
	de 2; 2; 3 y 3 metros, en ese orden).
	Sin embargo, la programación dinámica era costosa porque necesitaba almacenar
	un vector para cada permutación de trozos, lo cual tampoco era muy eficiente.

	Una vez descartado el caso anterior, recurrí al consejo dado en el PDF
	entregado en clase, y di con el resultado.

	Una vez más aprendí que no debo mostrarme tan reacio a tomar el camino
	aparentemente ingenuo.


\section{Flowers Flourish from France}

	Este problema no fue difícil de resolver.

	Había que hallar la priemra letra de cada palabra, convertirla a mayúsculas
	y controlar si siempre se repetía la misma letra hasta llegar a un salto de
	línea.

	La parte más tediosa del algoritmo fue hacer el parseo controlando que
	no hubiera errores de desatención.